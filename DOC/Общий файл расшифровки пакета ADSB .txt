–ü—Ä–æ–≥—Ä–∞–º–º–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ –ø–∞–∫–µ—Ç–∞ ADS-B –¥–ª—è Arduino IDE

–í–æ—Ç –ø–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã –¥–ª—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –∞–Ω–∞–ª–∏–∑–∞ –ø–∞–∫–µ—Ç–æ–≤ ADS-B –Ω–∞ Arduino:

ads_b_decoder.ino - –û—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª


/*
 * ADS-B Message Decoder for Arduino
 * –ü–æ–ª–Ω–∞—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –∏ –∞–Ω–∞–ª–∏–∑ –ø–∞–∫–µ—Ç–æ–≤ ADS-B
 * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤—Å–µ –æ—Å–Ω–æ–≤–Ω—ã–µ —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π
 * –ê–≤—Ç–æ—Ä: [–í–∞—à–µ –∏–º—è]
 * –î–∞—Ç–∞: 14.07.2025
 */

#include <Arduino.h>

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ADS-B
#define ADS_B_DATA_LENGTH 14
#define ADS_B_CRC_LENGTH 3
#define ADS_B_TOTAL_LENGTH 17
#define CRC24_POLYNOMIAL 0x1FFF409UL

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
struct ADSBMessage {
  uint8_t downlink_format;
  uint8_t capability;
  uint32_t icao_address;
  uint8_t type_code;
  uint8_t message_type;
  uint8_t raw_data[ADS_B_DATA_LENGTH];
  bool crc_valid;
};

struct AircraftPosition {
  bool valid;
  double latitude;
  double longitude;
  uint16_t altitude_feet;
  uint8_t cpr_format;
  uint32_t cpr_lat;
  uint32_t cpr_lon;
  uint8_t surveillance_status;
  uint8_t nic_supplement_b;
  uint8_t altitude_type;
  bool time_flag;
  bool cpr_odd_even;
};

struct AircraftVelocity {
  bool valid;
  uint16_t ground_speed_knots;
  uint16_t track_degrees;
  int16_t vertical_rate_fpm;
  uint8_t velocity_type;
  bool intent_change;
  bool ifr_capability;
  uint8_t navigation_accuracy;
  int16_t heading_degrees;
  bool supersonic;
};

struct AircraftIdentification {
  bool valid;
  char callsign[9];
  uint8_t aircraft_category;
  uint8_t emitter_category;
};

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
uint32_t crc_table[256];
bool table_initialized = false;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è CRC —Ç–∞–±–ª–∏—Ü—ã
void initializeCRCTable() {
  if (table_initialized) return;

  for (int i = 0; i < 256; i++) {
    uint32_t crc = (uint32_t)i << 16;

    for (int j = 0; j < 8; j++) {
      if (crc & 0x800000UL) {
        crc = ((crc << 1) ^ CRC24_POLYNOMIAL) & 0xFFFFFFUL;
      } else {
        crc = (crc << 1) & 0xFFFFFFUL;
      }
    }
    crc_table[i] = crc;
  }
  table_initialized = true;
}

// –†–∞—Å—á–µ—Ç CRC-24
uint32_t calculateCRC24(const uint8_t* data, uint8_t length) {
  if (!table_initialized) initializeCRCTable();

  uint32_t crc = 0x000000UL;

  for (uint8_t i = 0; i < length; i++) {
    uint8_t table_index = ((crc >> 16) ^ data[i]) & 0xFF;
    crc = ((crc << 8) ^ crc_table[table_index]) & 0xFFFFFFUL;
  }

  return crc;
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ CRC –ø–∞–∫–µ—Ç–∞
bool verifyCRC(const uint8_t* packet) {
  uint32_t calculated_crc = calculateCRC24(packet, ADS_B_DATA_LENGTH);
  uint32_t received_crc = ((uint32_t)packet[14] << 16) |
                          ((uint32_t)packet[15] << 8) |
                          (uint32_t)packet[16];
  return calculated_crc == received_crc;
}

// –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –±–∏—Ç–æ–≤ –∏–∑ –º–∞—Å—Å–∏–≤–∞ –±–∞–π—Ç
uint32_t extractBits(const uint8_t* data, uint8_t start_bit, uint8_t num_bits) {
  uint32_t result = 0;

  for (uint8_t i = 0; i < num_bits; i++) {
    uint8_t byte_index = (start_bit + i) / 8;
    uint8_t bit_index = 7 - ((start_bit + i) % 8);

    if (data[byte_index] & (1 << bit_index)) {
      result |= (1UL << (num_bits - 1 - i));
    }
  }

  return result;
}

// –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
ADSBMessage decodeADSBMessage(const uint8_t* packet) {
  ADSBMessage msg = {};

  // –ö–æ–ø–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
  memcpy(msg.raw_data, packet, ADS_B_DATA_LENGTH);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º CRC
  msg.crc_valid = verifyCRC(packet);

  // –ò–∑–≤–ª–µ–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è
  msg.downlink_format = (packet[0] >> 3) & 0x1F;
  msg.capability = packet[0] & 0x07;

  // ICAO –∞–¥—Ä–µ—Å (24 –±–∏—Ç–∞)
  msg.icao_address = ((uint32_t)packet[1] << 16) |
                     ((uint32_t)packet[2] << 8) |
                     (uint32_t)packet[3];

  // Type Code (–ø–µ—Ä–≤—ã–µ 5 –±–∏—Ç ME –ø–æ–ª—è)
  msg.type_code = (packet[4] >> 3) & 0x1F;

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è
  if (msg.type_code >= 1 && msg.type_code <= 4) {
    msg.message_type = 1; // Aircraft Identification
  } else if (msg.type_code >= 9 && msg.type_code <= 18) {
    msg.message_type = 2; // Airborne Position
  } else if (msg.type_code >= 20 && msg.type_code <= 22) {
    msg.message_type = 3; // Airborne Position (GNSS Height)
  } else if (msg.type_code == 19) {
    msg.message_type = 4; // Airborne Velocity
  } else {
    msg.message_type = 0; // Unknown/Other
  }

  return msg;
}

// –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞
AircraftIdentification decodeIdentification(const ADSBMessage& msg) {
  AircraftIdentification ident = {};

  if (msg.type_code < 1 || msg.type_code > 4) {
    ident.valid = false;
    return ident;
  }

  ident.valid = true;
  ident.aircraft_category = msg.type_code;

  // –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ callsign (—Å–∏–º–≤–æ–ª—ã –∫–æ–¥–∏—Ä—É—é—Ç—Å—è –≤ 6 –±–∏—Ç–∞—Ö –∫–∞–∂–¥—ã–π)
  const char charset[] = "#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####_###############0123456789######";

  for (uint8_t i = 0; i < 8; i++) {
    uint8_t char_bits = extractBits(msg.raw_data, 40 + i * 6, 6);
    ident.callsign[i] = charset[char_bits];
  }
  ident.callsign[8] = '\0';

  // –£–¥–∞–ª—è–µ–º trailing —Å–∏–º–≤–æ–ª—ã
  for (int i = 7; i >= 0; i--) {
    if (ident.callsign[i] == '#' || ident.callsign[i] == '_') {
      ident.callsign[i] = '\0';
    } else {
      break;
    }
  }

  return ident;
}

// –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞
AircraftPosition decodePosition(const ADSBMessage& msg) {
  AircraftPosition pos = {};

  if ((msg.type_code < 9 || msg.type_code > 18) &&
      (msg.type_code < 20 || msg.type_code > 22)) {
    pos.valid = false;
    return pos;
  }

  pos.valid = true;

  // Surveillance Status (2 –±–∏—Ç–∞)
  pos.surveillance_status = extractBits(msg.raw_data, 35, 2);

  // NIC Supplement B
  pos.nic_supplement_b = extractBits(msg.raw_data, 37, 1);

  // Altitude (12 –±–∏—Ç)
  uint16_t alt_encoded = extractBits(msg.raw_data, 40, 12);
  pos.altitude_type = extractBits(msg.raw_data, 47, 1); // Q bit

  if (pos.altitude_type) {
    // 25ft increment
    pos.altitude_feet = ((alt_encoded & 0xFF0) >> 1) * 25 - 1000;
  } else {
    // Gillham code (–±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ)
    pos.altitude_feet = 0; // –£–ø—Ä–æ—â–µ–Ω–Ω–æ
  }

  // Time flag
  pos.time_flag = extractBits(msg.raw_data, 52, 1);

  // CPR format (Odd/Even frame indicator)
  pos.cpr_odd_even = extractBits(msg.raw_data, 53, 1);
  pos.cpr_format = pos.cpr_odd_even;

  // Encoded latitude and longitude (17 bits each)
  pos.cpr_lat = extractBits(msg.raw_data, 54, 17);
  pos.cpr_lon = extractBits(msg.raw_data, 71, 17);

  // –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (—Ç—Ä–µ–±—É–µ—Ç –ø–∞—Ä–Ω—ã–µ –∫–∞–¥—Ä—ã –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏)
  // –≠—Ç–æ –±–∞–∑–æ–≤–æ–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
  pos.latitude = (double)pos.cpr_lat / 131072.0 * (pos.cpr_odd_even ? 360.0/59.0 : 360.0/60.0) - 90.0;
  pos.longitude = (double)pos.cpr_lon / 131072.0 * 360.0 - 180.0;

  return pos;
}

// –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞
AircraftVelocity decodeVelocity(const ADSBMessage& msg) {
  AircraftVelocity vel = {};

  if (msg.type_code != 19) {
    vel.valid = false;
    return vel;
  }

  vel.valid = true;

  // Subtype (3 bits)
  uint8_t subtype = extractBits(msg.raw_data, 37, 3);
  vel.velocity_type = subtype;

  // Intent change flag
  vel.intent_change = extractBits(msg.raw_data, 40, 1);

  // IFR capability flag
  vel.ifr_capability = extractBits(msg.raw_data, 41, 1);

  // Navigation Accuracy Category for Velocity
  vel.navigation_accuracy = extractBits(msg.raw_data, 42, 3);

  if (subtype == 1 || subtype == 2) {
    // Ground speed and track angle

    // East-West velocity component
    bool ew_sign = extractBits(msg.raw_data, 45, 1);
    uint16_t ew_velocity = extractBits(msg.raw_data, 46, 10);

    // North-South velocity component
    bool ns_sign = extractBits(msg.raw_data, 56, 1);
    uint16_t ns_velocity = extractBits(msg.raw_data, 57, 10);

    if (ew_velocity != 0 && ns_velocity != 0) {
      int16_t ew_vel = ew_sign ? -(ew_velocity - 1) : (ew_velocity - 1);
      int16_t ns_vel = ns_sign ? -(ns_velocity - 1) : (ns_velocity - 1);

      // Calculate ground speed and track
      vel.ground_speed_knots = sqrt(ew_vel  ew_vel + ns_vel  ns_vel);
      vel.track_degrees = atan2(ew_vel, ns_vel) * 180.0 / PI;
      if (vel.track_degrees < 0) vel.track_degrees += 360;
    }

    // Vertical rate
    bool vr_sign = extractBits(msg.raw_data, 67, 1);
    uint16_t vr_value = extractBits(msg.raw_data, 68, 9);

    if (vr_value != 0) {
      vel.vertical_rate_fpm = vr_sign ? -(vr_value - 1)  64 : (vr_value - 1)  64;
    }

  } else if (subtype == 3 || subtype == 4) {
    // Airspeed and heading

    // Heading status
    bool heading_available = extractBits(msg.raw_data, 45, 1);

    if (heading_available) {
      uint16_t heading = extractBits(msg.raw_data, 46, 10);
      vel.heading_degrees = heading * 360 / 1024;
    }

    // Airspeed type (IAS or TAS)
    bool airspeed_type = extractBits(msg.raw_data, 56, 1);
    uint16_t airspeed = extractBits(msg.raw_data, 57, 10);

    if (airspeed != 0) {
      vel.ground_speed_knots = airspeed - 1; // –ü—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
    }

    // Vertical rate (same as above)
    bool vr_sign = extractBits(msg.raw_data, 67, 1);
    uint16_t vr_value = extractBits(msg.raw_data, 68, 9);

    if (vr_value != 0) {
      vel.vertical_rate_fpm = vr_sign ? -(vr_value - 1)  64 : (vr_value - 1)  64;
    }
  }

  return vel;
}

// –§—É–Ω–∫—Ü–∏–∏ –≤—ã–≤–æ–¥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
void printHex(const uint8_t* data, uint8_t length) {
  for (uint8_t i = 0; i < length; i++) {
    if (data[i] < 16) Serial.print("0");
    Serial.print(data[i], HEX);
    if (i < length - 1) Serial.print(" ");
  }
}

void printADSBMessage(const ADSBMessage& msg) {
  Serial.println(F("\n=== –ê–Ω–∞–ª–∏–∑ ADS-B —Å–æ–æ–±—â–µ–Ω–∏—è ==="));

  Serial.print(F("–ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: "));
  printHex(msg.raw_data, ADS_B_DATA_LENGTH);
  Serial.println();

  Serial.print(F("CRC —Å—Ç–∞—Ç—É—Å: "));
  Serial.println(msg.crc_valid ? F("–í–ê–õ–ò–î–ï–ù") : F("–û–®–ò–ë–ö–ê"));

  Serial.print(F("Downlink Format: "));
  Serial.println(msg.downlink_format);

  Serial.print(F("Capability: "));
  Serial.println(msg.capability);

  Serial.print(F("ICAO –∞–¥—Ä–µ—Å: 0x"));
  if (msg.icao_address < 0x100000UL) Serial.print("0");
  if (msg.icao_address < 0x10000UL) Serial.print("0");
  if (msg.icao_address < 0x1000UL) Serial.print("0");
  if (msg.icao_address < 0x100UL) Serial.print("0");
  if (msg.icao_address < 0x10UL) Serial.print("0");
  Serial.println(msg.icao_address, HEX);

  Serial.print(F("Type Code: "));
  Serial.println(msg.type_code);

  Serial.print(F("–¢–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è: "));
  switch (msg.message_type) {
    case 1: Serial.println(F("–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –í–°")); break;
    case 2: Serial.println(F("–ü–æ–∑–∏—Ü–∏—è –í–° (–±–∞—Ä–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è)")); break;
    case 3: Serial.println(F("–ü–æ–∑–∏—Ü–∏—è –í–° (GNSS)")); break;
    case 4: Serial.println(F("–°–∫–æ—Ä–æ—Å—Ç—å –í–°")); break;
    default: Serial.println(F("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π/–î—Ä—É–≥–æ–π")); break;
  }

  Serial.println();
}

void printIdentification(const AircraftIdentification& ident) {
  if (!ident.valid) {
    Serial.println(F("–î–∞–Ω–Ω—ã–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã"));
    return;
  }

  Serial.println(F("=== –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞ ==="));

  Serial.print(F("–ü–æ–∑—ã–≤–Ω–æ–π: \""));
  Serial.print(ident.callsign);
  Serial.println("\"");

  Serial.print(F("–ö–∞—Ç–µ–≥–æ—Ä–∏—è –í–°: "));
  switch (ident.aircraft_category) {
    case 1: Serial.println(F("Light")); break;
    case 2: Serial.println(F("Small")); break;
    case 3: Serial.println(F("Large")); break;
    case 4: Serial.println(F("High Vortex Large")); break;
    default: Serial.println(F("Unknown")); break;
  }

  Serial.println();
}

void printPosition(const AircraftPosition& pos) {
  if (!pos.valid) {
    Serial.println(F("–î–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã"));
    return;
  }

  Serial.println(F("=== –ü–æ–∑–∏—Ü–∏—è –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞ ==="));

  Serial.print(F("–®–∏—Ä–æ—Ç–∞: "));
  Serial.print(pos.latitude, 6);
  Serial.println(F("¬∞"));

  Serial.print(F("–î–æ–ª–≥–æ—Ç–∞: "));
  Serial.print(pos.longitude, 6);
  Serial.println(F("¬∞"));

  Serial.print(F("–í—ã—Å–æ—Ç–∞: "));
  Serial.print(pos.altitude_feet);
  Serial.println(F(" —Ñ—É—Ç–æ–≤"));

  Serial.print(F("CPR —Ñ–æ—Ä–º–∞—Ç: "));
  Serial.println(pos.cpr_odd_even ? F("–ù–µ—á–µ—Ç–Ω—ã–π") : F("–ß–µ—Ç–Ω—ã–π"));

  Serial.print(F("–°—Ç–∞—Ç—É—Å –Ω–∞–±–ª—é–¥–µ–Ω–∏—è: "));
  Serial.println(pos.surveillance_status);

  Serial.print(F("–¢–∏–ø –≤—ã—Å–æ—Ç—ã: "));
  Serial.println(pos.altitude_type ? F("–ë–∞—Ä–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è") : F("Gillham –∫–æ–¥"));

  Serial.println();
}

void printVelocity(const AircraftVelocity& vel) {
  if (!vel.valid) {
    Serial.println(F("–î–∞–Ω–Ω—ã–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã"));
    return;
  }

  Serial.println(F("=== –°–∫–æ—Ä–æ—Å—Ç—å –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞ ==="));

  Serial.print(F("–ü—É—Ç–µ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å: "));
  Serial.print(vel.ground_speed_knots);
  Serial.println(F(" —É–∑–ª–æ–≤"));

  Serial.print(F("–ü—É—Ç–µ–≤–æ–π —É–≥–æ–ª: "));
  Serial.print(vel.track_degrees);
  Serial.println(F("¬∞"));

  Serial.print(F("–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å: "));
  Serial.print(vel.vertical_rate_fpm);
  Serial.println(F(" —Ñ—É—Ç/–º–∏–Ω"));

  Serial.print(F("–¢–∏–ø —Å–∫–æ—Ä–æ—Å—Ç–∏: "));
  Serial.println(vel.velocity_type);

  Serial.print(F("–ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞–º–µ—Ä–µ–Ω–∏–π: "));
  Serial.println(vel.intent_change ? F("–î–∞") : F("–ù–µ—Ç"));

  Serial.print(F("IFR –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å: "));
  Serial.println(vel.ifr_capability ? F("–î–∞") : F("–ù–µ—Ç"));

  Serial.println();
}

// –ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ø–∞–∫–µ—Ç–∞
void analyzeADSBPacket(const uint8_t* packet) {
  ADSBMessage msg = decodeADSBMessage(packet);
  printADSBMessage(msg);

  if (!msg.crc_valid) {
    Serial.println(F("‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: CRC –Ω–µ –≤–∞–ª–∏–¥–µ–Ω, –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø–æ–≤—Ä–µ–∂–¥–µ–Ω—ã"));
    return;
  }

  switch (msg.message_type) {
    case 1: {
      AircraftIdentification ident = decodeIdentification(msg);
      printIdentification(ident);
      break;
    }

    case 2:
    case 3: {
      AircraftPosition pos = decodePosition(msg);
      printPosition(pos);
      break;
    }

    case 4: {
      AircraftVelocity vel = decodeVelocity(msg);
      printVelocity(vel);
      break;
    }

    default:
      Serial.println(F("–¢–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞"));
      break;
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ hex —Å—Ç—Ä–æ–∫–∏
void processHexData(String hexData) {
  hexData.trim();
  hexData.toUpperCase();
  hexData.replace(" ", "");

  if (hexData.length() != 28 && hexData.length() != 34) {
    Serial.println(F("–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω–∞—è –¥–ª–∏–Ω–∞ hex –¥–∞–Ω–Ω—ã—Ö"));
    Serial.println(F("–û–∂–∏–¥–∞–µ—Ç—Å—è 28 —Å–∏–º–≤–æ–ª–æ–≤ (–¥–∞–Ω–Ω—ã–µ) –∏–ª–∏ 34 —Å–∏–º–≤–æ–ª–∞ (–ø–∞–∫–µ—Ç)"));
    return;
  }

  uint8_t packet[ADS_B_TOTAL_LENGTH] = {0};
  uint8_t length = hexData.length() / 2;

  // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º hex –≤ –±–∞–π—Ç—ã
  for (uint8_t i = 0; i < length; i++) {
    String byteStr = hexData.substring(i  2, i  2 + 2);
    packet[i] = strtoul(byteStr.c_str(), NULL, 16);
  }

  if (length == ADS_B_DATA_LENGTH) {
    Serial.println(F("‚ö†Ô∏è –î–∞–Ω–Ω—ã–µ –±–µ–∑ CRC - –¥–æ–±–∞–≤–ª—è–µ–º –Ω—É–ª–µ–≤–æ–π CRC"));
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω—É–ª–µ–≤–æ–π CRC –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
  }

  analyzeADSBPacket(packet);
}

// –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã
void runDemoExamples() {
  Serial.println(F("\n=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã ===\n"));

  // –ü—Ä–∏–º–µ—Ä 1: Aircraft Identification
  Serial.println(F("üìã –ü—Ä–∏–º–µ—Ä 1: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞"));
  uint8_t example1[] = {
    0x8D, 0x48, 0x40, 0x44, 0x20, 0x2C, 0xC3, 0x71,
    0xC3, 0x2C, 0xE0, 0x57, 0x60, 0x98, 0x2B, 0x7F, 0xB8
  };
  analyzeADSBPacket(example1);

  // –ü—Ä–∏–º–µ—Ä 2: Airborne Position
  Serial.println(F("üõ©Ô∏è –ü—Ä–∏–º–µ—Ä 2: –ü–æ–∑–∏—Ü–∏—è –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞"));
  uint8_t example2[] = {
    0x8D, 0x40, 0x62, 0x1D, 0x58, 0xC3, 0x82, 0xD6,
    0x90, 0xC8, 0xAC, 0x28, 0x00, 0x00, 0xA7, 0x83, 0x2F
  };
  analyzeADSBPacket(example2);

  // –ü—Ä–∏–º–µ—Ä 3: Velocity
  Serial.println(F("üí® –ü—Ä–∏–º–µ—Ä 3: –°–∫–æ—Ä–æ—Å—Ç—å –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞"));
  uint8_t example3[] = {
    0x8D, 0x40, 0x62, 0x1D, 0x99, 0x11, 0x59, 0x15,
    0x45, 0x53, 0x20, 0x00, 0x00, 0x00, 0x5D, 0x73, 0x91
  };
  analyzeADSBPacket(example3);
}

// –ö–æ–º–∞–Ω–¥—ã Serial
void processSerialCommand() {
  if (!Serial.available()) return;

  String command = Serial.readStringUntil('\n');
  command.trim();
  command.toUpperCase();

  if (command == "HELP" || command == "?") {
    printHelp();
  }
  else if (command == "DEMO") {
    runDemoExamples();
  }
  else if (command.startsWith("DECODE ")) {
    processHexData(command.substring(7));
  }
  else if (command.startsWith("HEX ")) {
    processHexData(command.substring(4));
  }
  else if (command.length() > 0) {
    // –ü–æ–ø—ã—Ç–∫–∞ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∫ hex –¥–∞–Ω–Ω—ã–µ
    if (command.length() == 28 || command.length() == 34) {
      processHexData(command);
    } else {
      Serial.println(F("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –í–≤–µ–¥–∏—Ç–µ HELP –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏."));
    }
  }
}

void printHelp() {
  Serial.println(F("\n=== ADS-B Message Decoder - –ö–æ–º–∞–Ω–¥—ã ==="));
  Serial.println(F("HELP –∏–ª–∏ ?           - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞"));
  Serial.println(F("DEMO                 - –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã"));
  Serial.println(F("DECODE <hex>         - –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å hex –¥–∞–Ω–Ω—ã–µ"));
  Serial.println(F("HEX <hex>            - –ê–ª–∏–∞—Å –¥–ª—è DECODE"));
  Serial.println(F("<hex_data>           - –ü—Ä—è–º–æ–π –≤–≤–æ–¥ hex –¥–∞–Ω–Ω—ã—Ö"));
  Serial.println(F(""));
  Serial.println(F("–ü—Ä–∏–º–µ—Ä—ã:"));
  Serial.println(F("DECODE 8D4840442C71C32CE05760982B7FB8"));
  Serial.println(F("HEX 8D40621D58C382D690C8AC280000A7832F"));
  Serial.println(F("8D40621D99115915455320000005D7391"));
  Serial.println(F(""));
  Serial.println(F("–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π:"));
  Serial.println(F("‚Ä¢ –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞ (TC 1-4)"));
  Serial.println(F("‚Ä¢ –ü–æ–∑–∏—Ü–∏—è –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞ (TC 9-18, 20-22)"));
  Serial.println(F("‚Ä¢ –°–∫–æ—Ä–æ—Å—Ç—å –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞ (TC 19)"));
  Serial.println();
}

int freeMemory() {
  char top;
#ifdef __arm__
  return &top - reinterpret_cast<char*>(sbrk(0));
#elif defined(CORE_TEENSY) || (ARDUINO > 103 && ARDUINO != 151)
  return &top - __brkval;
#else
  return __brkval ? &top - __brkval : &top - __malloc_heap_start;
#endif
}

void setup() {
  Serial.begin(115200);
  while (!Serial) {
    ; // –ñ–¥–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è Serial –¥–ª—è Leonardo/Micro
  }

  Serial.println(F("ADS-B Message Decoder –¥–ª—è Arduino"));
  Serial.println(F("================================="));
  Serial.print(F("–°–≤–æ–±–æ–¥–Ω–∞—è –ø–∞–º—è—Ç—å: "));
  Serial.print(freeMemory());
  Serial.println(F(" –±–∞–π—Ç"));
  Serial.println();

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è CRC
  initializeCRCTable();
  Serial.println(F("‚úÖ CRC —Ç–∞–±–ª–∏—Ü–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞"));

  Serial.println(F("‚ÑπÔ∏è –ì–æ—Ç–æ–≤ –∫ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—é ADS-B —Å–æ–æ–±—â–µ–Ω–∏–π"));
  Serial.println(F("–í–≤–µ–¥–∏—Ç–µ HELP –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø—Ä–∞–≤–∫–∏"));
  Serial.println(F("–í–≤–µ–¥–∏—Ç–µ DEMO –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤"));
  Serial.print(F("> "));
}

void loop() {
  processSerialCommand();
  delay(10);
}


ads_b_cpr.h - –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –º–æ–¥—É–ª—å –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç


/*
 * CPR (Compact Position Reporting) –¥–µ–∫–æ–¥–µ—Ä –¥–ª—è —Ç–æ—á–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
 * –¢—Ä–µ–±—É–µ—Ç –¥–≤–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –∫–∞–¥—Ä–∞ (—á–µ—Ç–Ω—ã–π –∏ –Ω–µ—á–µ—Ç–Ω—ã–π)
 */

#ifndef ADS_B_CPR_H
#define ADS_B_CPR_H

#include <Arduino.h>
#include <math.h>

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è CPR –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
#define DLAT_EVEN (360.0 / 60.0)   // 6.0
#define DLAT_ODD  (360.0 / 59.0)   // 6.101694915...
#define CPR_MAX   131072.0         // 2^17

struct CPRFrame {
  bool valid;
  bool odd_even;  // 0 = even, 1 = odd
  uint32_t cpr_lat;
  uint32_t cpr_lon;
  uint32_t timestamp;
};

struct DecodedPosition {
  bool valid;
  double latitude;
  double longitude;
  bool globally_unambiguous;
};

class CPRDecoder {
private:
  CPRFrame even_frame;
  CPRFrame odd_frame;
  bool has_even_frame;
  bool has_odd_frame;

  static double mod(double a, double b) {
    return a - b * floor(a / b);
  }

  static uint8_t nl(double lat) {
    if (abs(lat) >= 87.0) return 1;
    return floor(2.0  PI / acos(1.0 - (1.0 - cos(PI / (2.0  15.0))) /
                                 pow(cos(PI * lat / 180.0), 2.0)));
  }

public:
  CPRDecoder() : has_even_frame(false), has_odd_frame(false) {}

  void addFrame(bool odd_even, uint32_t cpr_lat, uint32_t cpr_lon, uint32_t timestamp) {
    if (odd_even) {
      odd_frame = {true, true, cpr_lat, cpr_lon, timestamp};
      has_odd_frame = true;
    } else {
      even_frame = {true, false, cpr_lat, cpr_lon, timestamp};
      has_even_frame = true;
    }
  }

  DecodedPosition decodeGlobal() {
    DecodedPosition result = {};

    if (!has_even_frame || !has_odd_frame) {
      result.valid = false;
      return result;
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–∞–¥—Ä—ã –Ω–µ —Å–ª–∏—à–∫–æ–º —Å—Ç–∞—Ä—ã–µ (–º–∞–∫—Å–∏–º—É–º 10 —Å–µ–∫—É–Ω–¥ —Ä–∞–∑–Ω–∏—Ü–∞)
    if (abs((long)(odd_frame.timestamp - even_frame.timestamp)) > 10000) {
      result.valid = false;
      return result;
    }

    double dlat_even = DLAT_EVEN;
    double dlat_odd = DLAT_ODD;

    // –í—ã—á–∏—Å–ª—è–µ–º –∏–Ω–¥–µ–∫—Å —à–∏—Ä–æ—Ç—ã
    double j = floor(((59.0  even_frame.cpr_lat - 60.0  odd_frame.cpr_lat) / CPR_MAX) + 0.5);

    double rlat_even = dlat_even * (mod(j, 60.0) + even_frame.cpr_lat / CPR_MAX);
    double rlat_odd = dlat_odd * (mod(j, 59.0) + odd_frame.cpr_lat / CPR_MAX);

    // –ü—Ä–∏–≤–æ–¥–∏–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [-90, 90]
    if (rlat_even >= 270.0) rlat_even -= 360.0;
    if (rlat_odd >= 270.0) rlat_odd -= 360.0;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —à–∏—Ä–æ—Ç
    if (abs(rlat_even - rlat_odd) > 1.0) {
      result.valid = false;
      return result;
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ —Å–≤–µ–∂–∏–π –∫–∞–¥—Ä –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —à–∏—Ä–æ—Ç—ã
    double rlat;
    bool use_odd;
    if (odd_frame.timestamp > even_frame.timestamp) {
      rlat = rlat_odd;
      use_odd = true;
    } else {
      rlat = rlat_even;
      use_odd = false;
    }

    // –í—ã—á–∏—Å–ª—è–µ–º –¥–æ–ª–≥–æ—Ç—É
    uint8_t nl_lat = nl(rlat);
    uint8_t nl_lat_1 = nl(rlat - (use_odd ? dlat_odd : dlat_even));

    if (nl_lat != nl_lat_1) {
      result.valid = false;
      return result;
    }

    if (nl_lat == 0) nl_lat = 1;  // –ò–∑–±–µ–≥–∞–µ–º –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å

    double dlon = 360.0 / nl_lat;
    double m = floor(((even_frame.cpr_lon  (nl_lat - 1) - odd_frame.cpr_lon  nl_lat) / CPR_MAX) + 0.5);

    double rlon;
    if (use_odd) {
      rlon = dlon * (mod(m, nl_lat) + odd_frame.cpr_lon / CPR_MAX);
    } else {
      rlon = dlon * (mod(m, nl_lat) + even_frame.cpr_lon / CPR_MAX);
    }

    // –ü—Ä–∏–≤–æ–¥–∏–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [-180, 180]
    if (rlon > 180.0) rlon -= 360.0;
    if (rlon < -180.0) rlon += 360.0;

    result.valid = true;
    result.latitude = rlat;
    result.longitude = rlon;
    result.globally_unambiguous = true;

    return result;
  }

  // –õ–æ–∫–∞–ª—å–Ω–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ (—Ç—Ä–µ–±—É–µ—Ç –∏–∑–≤–µ—Å—Ç–Ω—É—é –ø–æ–∑–∏—Ü–∏—é)
  DecodedPosition decodeLocal(double ref_lat, double ref_lon, bool odd_even,
                             uint32_t cpr_lat, uint32_t cpr_lon) {
    DecodedPosition result = {};

    double dlat = odd_even ? DLAT_ODD : DLAT_EVEN;
    double j = floor(ref_lat / dlat) + floor(0.5 + mod(ref_lat, dlat) / dlat - cpr_lat / CPR_MAX);

    double rlat = dlat * (j + cpr_lat / CPR_MAX);

    uint8_t nl_lat = nl(rlat);
    if (nl_lat == 0) nl_lat = 1;

    double dlon = 360.0 / nl_lat;
    double m = floor(ref_lon / dlon) + floor(0.5 + mod(ref_lon, dlon) / dlon - cpr_lon / CPR_MAX);

    double rlon = dlon * (m + cpr_lon / CPR_MAX);

    result.valid = true;
    result.latitude = rlat;
    result.longitude = rlon;
    result.globally_unambiguous = false;

    return result;
  }

  void reset() {
    has_even_frame = false;
    has_odd_frame = false;
  }
};

#endif // ADS_B_CPR_H


–ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∏ –≤—ã–≤–æ–¥–∞

–ü—Ä–∏ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏:

=== –ê–Ω–∞–ª–∏–∑ ADS-B —Å–æ–æ–±—â–µ–Ω–∏—è ===
–ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: 8D 48 40 44 20 2C C3 71 C3 2C E0 57 60 98
CRC —Å—Ç–∞—Ç—É—Å: –í–ê–õ–ò–î–ï–ù
Downlink Format: 17
Capability: 5
ICAO –∞–¥—Ä–µ—Å: 0x484044
Type Code: 4
–¢–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –í–°

=== –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞ ===
–ü–æ–∑—ã–≤–Ω–æ–π: "KLM1023_"
–ö–∞—Ç–µ–≥–æ—Ä–∏—è –í–°: High Vortex Large


–ü—Ä–∏ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–∏:

=== –ü–æ–∑–∏—Ü–∏—è –≤–æ–∑–¥—É—à–Ω–æ–≥–æ —Å—É–¥–Ω–∞ ===
–®–∏—Ä–æ—Ç–∞: 52.257202¬∞
–î–æ–ª–≥–æ—Ç–∞: 3.919373¬∞
–í—ã—Å–æ—Ç–∞: 38000 —Ñ—É—Ç–æ–≤
CPR —Ñ–æ—Ä–º–∞—Ç: –ß–µ—Ç–Ω—ã–π
–°—Ç–∞—Ç—É—Å –Ω–∞–±–ª—é–¥–µ–Ω–∏—è: 0
–¢–∏–ø –≤—ã—Å–æ—Ç—ã: –ë–∞—Ä–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è


–≠—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:
–ü–æ–ª–Ω–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤ ADS-B —Å–æ–æ–±—â–µ–Ω–∏–π
–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ —Å –ø–æ–º–æ—â—å—é CRC-24
–£–¥–æ–±–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é –ø–∞–º—è—Ç–∏ –¥–ª—è Arduino –ø–ª–∞—Ç—Ñ–æ—Ä–º 